# ERC-8128 Integration Guide for ClawCoach

> **Standard**: ERC-8128 — Signed HTTP Requests with Ethereum
> **Package**: `@slicekit/erc8128`
> **Status**: Draft ERC (January 2026)
> **Relevance**: Agent authentication, agent-to-agent comms, API security

---

## What ERC-8128 Does

ERC-8128 lets any Ethereum account — EOA or Smart Contract Account (via ERC-1271) — cryptographically authenticate HTTP requests. No API keys, no JWTs, no bearer tokens, no handshakes.

It's built on RFC 9421 (HTTP Message Signatures), the IETF standard for cryptographic request signing. The signer's Ethereum address becomes their identity through a `keyid` format: `erc8128:<chainId>:<address>`.

The signature binds to the actual HTTP request content (method, path, query, body), so any tampering breaks verification. Built-in nonce mechanism prevents replay attacks.

### The Paradigm Shift

Traditional HTTP auth: server issues credentials → client presents them back → server validates its own tokens.

ERC-8128: client signs requests with its wallet → any compliant server can verify → no prior relationship needed.

This is exactly what decentralized AI agents need.

---

## Why ClawCoach Needs This

ClawCoach's architecture has AI coaching agents that each possess:
- **ERC-8004 identity NFT** — onchain identity and reputation
- **Coinbase Smart Wallet** (2-of-2 multisig) — financial autonomy

The problem ERC-8128 solves: **How does an agent authenticate when it calls your backend API?**

Without ERC-8128, you'd need to issue API keys or JWTs to each spawned agent, manage rotation, handle revocation when agents are deactivated. That's centralized identity management bolted onto a decentralized system.

With ERC-8128, the agent's wallet *is* its authentication. The identity layer (ERC-8004) and the auth layer (ERC-8128) form a clean trust chain:

```
Agent spawned → ERC-8004 Identity NFT minted → Coinbase Smart Wallet created
                                                        │
                                                        ▼
                                    Agent signs HTTP requests with wallet
                                                        │
                                                        ▼
                                    Server verifies signature against
                                    known agent address from ERC-8004 registry
                                                        │
                                                        ▼
                                    Authenticated. No tokens issued or managed.
```

---

## Where ERC-8128 Fits in ClawCoach's Architecture

### Mapping to the Six-Layer Security Architecture

| Security Layer | Current Design | ERC-8128 Enhancement |
|---|---|---|
| **Layer 1: Agent Permissions** | Scoped actions per agent | Signed requests prove agent identity per-call |
| **Layer 2: Wallet Security** | 2-of-2 multisig Coinbase Smart Wallet | Wallet signs HTTP requests via ERC-1271 |
| **Layer 3: Trust Verification** | ERC-8004 Identity + Reputation registries | HTTP auth bound to onchain identity |
| **Layer 4: Data Protection** | Encrypted health data | Request integrity — tampered payloads fail verification |
| **Layer 5: Smart Contract Security** | Checks-effects-interactions, ReentrancyGuard | Complement: offchain API calls now have same identity guarantees as onchain txs |
| **Layer 6: Operational Security** | Monitoring, rate limiting | Nonce-based replay protection built into every request |

### Communication Flows That Benefit

1. **Agent → ClawCoach API**: Agent logs workouts, requests coaching data, triggers $CLAWC rewards
2. **Agent → Agent**: Coach agent delegates to a nutrition sub-agent (future)
3. **Agent → External Services**: Agent calls wearable APIs, health data connectors
4. **User → Agent**: User's wallet signs requests to their personal agent's endpoints

---

## Technical Implementation

### Install

```bash
pnpm add @slicekit/erc8128
# Already using viem in the stack — no additional deps
```

### Core Concepts

**Signer** — The entity signing requests (an agent's Coinbase Smart Wallet)

```typescript
import type { EthHttpSigner } from '@slicekit/erc8128'

type EthHttpSigner = {
  chainId: number          // Base = 8453, Base Sepolia = 84532
  address: Address         // Agent's smart wallet address
  signMessage: (message: Uint8Array) => Promise<Hex>  // Wallet's sign function
}
```

**Binding Modes:**
- `"request-bound"` (default) — Signs URL, method, headers, body. Full request integrity.
- `"class-bound"` — Signs a subset of components. Lighter, for less sensitive calls.

**Replay Protection:**
- `"non-replayable"` (default) — Includes nonce. Each request is unique.
- `"replayable"` — No nonce. Use only for idempotent reads.

### Agent-Side: Signing Requests

Each ClawCoach agent has a Coinbase Smart Wallet. The agent signs its API calls:

```typescript
// lib/agent-auth.ts
import { createSignerClient } from '@slicekit/erc8128'
import type { EthHttpSigner } from '@slicekit/erc8128'

/**
 * Create an authenticated HTTP client for a ClawCoach agent.
 * The agent's Smart Wallet signs every outgoing request.
 */
export function createAgentHttpClient(agentWallet: {
  address: Address
  signMessage: (message: Uint8Array) => Promise<Hex>
}) {
  const signer: EthHttpSigner = {
    chainId: 84532,  // Base Sepolia (testnet) — change to 8453 for mainnet
    address: agentWallet.address,
    signMessage: agentWallet.signMessage,
  }

  const client = createSignerClient(signer, {
    binding: 'request-bound',     // Full request integrity
    replay: 'non-replayable',     // Nonce-based replay protection
    ttlSeconds: 60,               // Signature valid for 60 seconds
    label: 'clawcoach',           // Custom label for ClawCoach signatures
  })

  return client
}

// Usage in agent runtime:
const agentClient = createAgentHttpClient(agentWallet)

// Log a completed workout — request is signed with agent's wallet
const response = await agentClient.fetch(
  'https://api.clawcoach.xyz/v1/workouts',
  {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      userId: 'user_abc123',
      type: 'strength',
      duration: 3600,
      exercises: [/* ... */],
      wearableData: {/* ... */},
    }),
  }
)

// Trigger $CLAWC reward — also signed
const rewardResponse = await agentClient.fetch(
  'https://api.clawcoach.xyz/v1/rewards/emit',
  {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      userId: 'user_abc123',
      workoutId: 'workout_xyz',
      fitAmount: '10.5',
    }),
  }
)
```

### Server-Side: Verifying Agent Requests

Your Next.js API routes verify that incoming requests are from legitimate agents:

```typescript
// lib/verify-agent.ts
import { createVerifierClient } from '@slicekit/erc8128'
import { createPublicClient, http } from 'viem'
import { baseSepolia } from 'viem/chains'
import type { NonceStore } from '@slicekit/erc8128'

// Viem public client for ERC-1271 signature verification
// (Smart Contract Accounts like Coinbase Smart Wallet use ERC-1271)
const publicClient = createPublicClient({
  chain: baseSepolia,
  transport: http(),
})

// Nonce store — prevents replay attacks
// Use Upstash Redis (already in your stack)
const nonceStore: NonceStore = {
  async consume(key: string, ttlSeconds: number): Promise<boolean> {
    // Redis SET with NX (only if not exists) + EX (expiry)
    // Returns true if nonce was fresh, false if already used
    const result = await redis.set(
      `nonce:${key}`,
      '1',
      { nx: true, ex: ttlSeconds }
    )
    return result === 'OK'
  },
}

// Create the verifier
export const agentVerifier = createVerifierClient(
  publicClient.verifyMessage,
  nonceStore,
  {
    maxValiditySec: 300,        // Max 5-minute signature window
    clockSkewSec: 5,            // Allow 5s clock drift
    label: 'clawcoach',         // Expect ClawCoach-labeled signatures
    strictLabel: false,         // Also accept default 'eth' label
    replayable: false,          // Require nonces on all requests
  }
)
```

### Next.js Middleware: Protecting API Routes

```typescript
// middleware/agent-auth.ts
import { agentVerifier } from '@/lib/verify-agent'
import { supabase } from '@/lib/supabase'

/**
 * Verify that an incoming request is from a registered ClawCoach agent.
 * Checks: 1) Valid ERC-8128 signature, 2) Address matches a registered agent.
 */
export async function verifyAgentRequest(request: Request) {
  // Step 1: Verify the cryptographic signature
  const result = await agentVerifier.verifyRequest(request)

  if (!result.ok) {
    return {
      authenticated: false,
      reason: result.reason,  // e.g. 'invalid-signature', 'expired', 'replay'
    }
  }

  // Step 2: Check the address against ERC-8004 agent registry
  // (or your Supabase agents table)
  const { data: agent } = await supabase
    .from('ai_coaching_agents')
    .select('id, user_id, status, wallet_address')
    .eq('wallet_address', result.address.toLowerCase())
    .eq('status', 'active')
    .single()

  if (!agent) {
    return {
      authenticated: false,
      reason: 'unknown-agent',
    }
  }

  return {
    authenticated: true,
    agentId: agent.id,
    userId: agent.user_id,
    address: result.address,
    chainId: result.chainId,
    binding: result.binding,       // 'request-bound' or 'class-bound'
    replayable: result.replayable, // false = nonce was consumed
  }
}
```

### API Route Example

```typescript
// app/api/v1/workouts/route.ts
import { verifyAgentRequest } from '@/middleware/agent-auth'
import { NextResponse } from 'next/server'

export async function POST(request: Request) {
  const auth = await verifyAgentRequest(request)

  if (!auth.authenticated) {
    return NextResponse.json(
      { error: 'Unauthorized', reason: auth.reason },
      { status: 401 }
    )
  }

  // auth.agentId, auth.userId, auth.address are all verified
  // Proceed with workout logging...

  const body = await request.json()

  // The agent can only act on behalf of its assigned user
  if (body.userId !== auth.userId) {
    return NextResponse.json(
      { error: 'Agent cannot act for this user' },
      { status: 403 }
    )
  }

  // ... create workout record, trigger $CLAWC reward, etc.
}
```

---

## Smart Contract Accounts (Coinbase Smart Wallet)

Coinbase Smart Wallet is a Smart Contract Account, not an EOA. ERC-8128 supports this via ERC-1271 — the standard for smart contract signature verification.

When verifying a signature from a Smart Contract Account:
1. The verifier calls `isValidSignature(hash, signature)` on the contract
2. The contract returns a magic value if the signature is valid
3. This happens transparently through viem's `verifyMessage`

Your Coinbase Smart Wallet's 2-of-2 multisig means the agent needs approval from its co-signer (your platform) to sign messages. This aligns with ClawCoach's security model — the agent can't unilaterally authenticate without platform co-signing.

```typescript
// The agent's smart wallet implements ERC-1271
// viem's verifyMessage handles this automatically:
const isValid = await publicClient.verifyMessage({
  address: agentWalletAddress,  // Smart contract address
  message: { raw: messageBytes },
  signature: signatureHex,
})
// For EOAs: ecrecover
// For Smart Contract Accounts: calls isValidSignature on the contract
```

---

## Integration with ERC-8004 (Trustless Agents)

ERC-8004 provides three registries: Identity, Reputation, and Validation. ERC-8128 complements these:

| ERC-8004 Registry | What It Does | ERC-8128 Connection |
|---|---|---|
| **Identity Registry** | Registers agent with metadata, capabilities | Agent's registered address is the same one signing HTTP requests |
| **Reputation Registry** | Tracks agent performance scores | Server can check reputation after verifying signature |
| **Validation Registry** | Third-party attestations | Validators can require ERC-8128 signed requests from agents they're validating |

### Combined Verification Flow

```
Incoming HTTP Request
        │
        ▼
  ERC-8128: Verify signature
  → Extract address + chainId
        │
        ▼
  ERC-8004 Identity Registry: Is this address a registered agent?
  → Get agent metadata, capabilities
        │
        ▼
  ERC-8004 Reputation Registry: What's the agent's reputation score?
  → Apply reputation-based rate limits or access tiers
        │
        ▼
  Supabase: Get agent's user assignment, active status
  → Authorize the specific action
        │
        ▼
  Process request
```

---

## Nonce Store Implementation (Upstash Redis)

Your stack already includes Upstash Redis. Here's the production nonce store:

```typescript
// lib/nonce-store.ts
import { Redis } from '@upstash/redis'
import type { NonceStore } from '@slicekit/erc8128'

const redis = Redis.fromEnv()

export const nonceStore: NonceStore = {
  async consume(key: string, ttlSeconds: number): Promise<boolean> {
    // SET NX ensures each nonce can only be used once
    // EX auto-expires after the TTL window passes
    const result = await redis.set(`erc8128:nonce:${key}`, '1', {
      nx: true,   // Only set if key doesn't exist
      ex: ttlSeconds, // Auto-expire
    })
    return result === 'OK'
  },
}
```

This is clean and production-ready. Each nonce key is unique per-request, stored with an automatic expiry matching the signature TTL. No cleanup needed.

---

## Sign Options Reference

### Signing (Agent-Side)

| Option | Type | Default | ClawCoach Recommendation |
|---|---|---|---|
| `binding` | `"request-bound"` \| `"class-bound"` | `"request-bound"` | Use `request-bound` for all write operations (POST/PUT/DELETE). `class-bound` acceptable for reads. |
| `replay` | `"non-replayable"` \| `"replayable"` | `"non-replayable"` | Always `non-replayable` for writes. `replayable` okay for idempotent GETs. |
| `ttlSeconds` | `number` | `60` | 60s for normal ops. 30s for $CLAWC reward triggers. |
| `label` | `string` | `"eth"` | Use `"clawcoach"` to namespace your signatures. |

### Verification (Server-Side)

| Option | Type | Default | ClawCoach Recommendation |
|---|---|---|---|
| `maxValiditySec` | `number` | `300` | 300s (5 min) — generous for network latency. |
| `clockSkewSec` | `number` | `0` | 5s — accounts for slight time drift between agent and server. |
| `replayable` | `boolean` | `false` | `false` — enforce nonces on all requests. |

---

## Verify Result Shape

When verification succeeds, you get rich context:

```typescript
type VerifyResult =
  | {
      ok: true
      address: Address      // Agent's wallet address (verified)
      chainId: number       // 84532 (Base Sepolia) or 8453 (Base mainnet)
      label: string         // 'clawcoach'
      components: string[]  // What was signed (method, path, body, etc.)
      params: SignatureParams
      replayable: boolean   // false = nonce was consumed
      binding: 'request-bound' | 'class-bound'
    }
  | {
      ok: false
      reason: VerifyFailReason  // 'invalid-signature' | 'expired' | 'replay' | etc.
    }
```

---

## Migration Strategy

### Phase 1: MVP (Testnet)
- Add ERC-8128 to agent runtime for API calls
- Implement verifier middleware on ClawCoach API routes
- Use Upstash Redis nonce store
- Fallback: also accept traditional auth during transition

### Phase 2: Agent-to-Agent (Post-MVP)
- Agents authenticate to each other via ERC-8128
- Combine with ERC-8004 reputation checks
- Enable delegation patterns (coach agent → nutrition sub-agent)

### Phase 3: External Services
- Agents present ERC-8128 signed requests to third-party APIs
- Wearable data providers can verify agent identity
- X402 gas abstraction for payment-authenticated requests

---

## Open Questions to Track

These are active discussions on the ERC that could affect implementation:

1. **`keyid` format** — Currently `erc8128:<chainId>:<address>`. May change to `eip155:<chainId>:<address>` or a hybrid. Watch the Ethereum Magicians thread.

2. **Multi-algorithm EOAs** — Future Ethereum accounts may use non-secp256k1 signing. Not relevant now (Coinbase Smart Wallet uses standard ECDSA), but worth monitoring.

3. **Fallback headers** — Some HTTP environments can't preserve Structured Fields. Optional fallback headers may be standardized. Could matter if agents call legacy APIs.

---

## Files to Create in ClawCoach Repo

| File | Purpose |
|---|---|
| `src/lib/agent-auth.ts` | `createAgentHttpClient()` — agent-side signing |
| `src/lib/verify-agent.ts` | `agentVerifier` — server-side verification setup |
| `src/lib/nonce-store.ts` | Upstash Redis NonceStore implementation |
| `src/middleware/agent-auth.ts` | `verifyAgentRequest()` — middleware for API routes |
| `docs/ERC-8128.md` | This document (architecture reference) |

---

## Key Dependencies

| Package | Version | Purpose |
|---|---|---|
| `@slicekit/erc8128` | latest | Sign/verify HTTP requests |
| `viem` | ^2.x | Already in stack — Ethereum interactions, ERC-1271 |
| `@upstash/redis` | Already in stack | Nonce store for replay protection |

---

## Resources

- [ERC-8128 Documentation](https://erc8128.slice.so)
- [GitHub: @slicekit/erc8128](https://github.com/slice-so/erc8128)
- [ERC-8128 Specification](https://github.com/slice-so/ERCs/blob/d9c6f41183008285a0e9f1af1d2aeac72e7a8fdc/ERCS/erc-8128.md)
- [Ethereum Magicians Discussion](https://ethereum-magicians.org/t/erc-8128-signed-http-requests-with-ethereum/27515)
- [Telegram Group](https://t.me/+oVfVGLx41x45YzE0)
- [ERC-8004 (Trustless Agents)](https://eips.ethereum.org/EIPS/eip-8004) — Companion standard for agent identity
- [ERC-1271](https://eips.ethereum.org/EIPS/eip-1271) — Smart Contract Account signature verification

---

*Generated: February 2026 — ClawCoach (formerly MoltCoach/TruthCoach)*
